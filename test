A piece of software provides access to computer resources (such as memory, CPU, storage, etc.) by its underlying computer system; the availability of these resources to other software can have major ramification sometimes disastrous ones or its functionality and stability. A key principle of design is to prohibit access to all resources by default, allowing access only through well-defined entry points, i.e. interfaces.[citation needed]
The types of access that interfaces provide between software components can include: constants, data types, types of procedures, exception specifications and method signatures. In some instances, it may be useful to define public variables as part of the interface. It often also specifies the functionality of those procedures and methods, either by comments or (in some experimental languages) by formal logical assertions and preconditions.
The interface of a software module A is deliberately kept separate from the implementation of that module. The latter contains the actual code of the procedures and methods described in the interface, as well as other "private" variables, procedures, etc.. Any other software module B (which can be referred to as a client to A) that interacts with A is forced to do so only through the interface. One practical advantage of this arrangement is that replacing the implementation of A by another one that meets the same specifications of the interface should not cause B to fail—as long as its use of A complies with the specifications of the interface. (See also Liskov substitution principle.)
[edit]Software interfaces in object oriented languages
Main article: Protocol (object-oriented programming)
In object-oriented languages the term "interface" is often used to define an abstract type that contains no data but exposes behaviors defined as methods. A class having all the methods corresponding to that interface is said to implement that interface. Furthermore, a class can implement multiple interfaces, and hence can be of different types at the same time.
An interface is hence a type definition; anywhere an object can be exchanged (in a function or method call) the type of the object to be exchanged can be defined in terms of an interface instead of a specific class. This allows later code to use the same function exchanging different object types; hence such code turns out to be more generic and reusable.
Usually a method in an interface cannot be used directly; there must be a class implementing that object to be used for the method invocation. For example, one can define an interface called "Stack" that has two methods: push() and pop() and later implement it in two different versions, say, FastStack and GenericStack—the first being faster but working with a stack of fixed size, and the second using a data structure that can be resized but at the cost of somewhat lower speed.
This approach can be pushed to the limit of defining interfaces with a single method; e.g. the Java language defines the interface Readable that has the single read() method and a collection of implementations to be used for different purposes, among others: BufferedReader, FileReader, InputStreamReader, PipedReader, and StringReader.
In its purest form, an interface (like in Java) must include only method definitions and constant values that make up part of the static interface of a type. Some languages (like C#) also permit the definition to include properties owned by the object, which are treated as methods with syntactic sugar.
[edit]Programming against software interfaces
The use of interfaces allows implementation of a programming style called programming against interfaces. The idea behind this is to base the logic one develops on the sole interface definition of the objects one uses and not to make the code depend on the internal details. This allows the programmer the ability to later change the behavior of the system by simply swapping the object used with another implementing the same interface.
Pushing this idea to the limit one can introduce the inversion of control which means leaving the context to inject the code with the specific implementations of the interface that will be used to perform the work.
